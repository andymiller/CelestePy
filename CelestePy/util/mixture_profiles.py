# Copyright 2011 David W. Hogg and Dustin Lang.  All rights reserved.

import numpy as np
import scipy.spatial.distance as scp
import scipy.misc as scpm

# magic arrays, generated by running optimize_mixture_profiles.py:
# (note optimize_mixture_profiles.py now lives in Hogg's TheTractor github repo)
exp_amp = np.array([  2.34853813e-03,   3.07995260e-02,   2.23364214e-01,
		      1.17949102e+00,   4.33873750e+00,   5.99820770e+00])
exp_var = np.array([  1.20078965e-03,   8.84526493e-03,   3.91463084e-02,
		      1.39976817e-01,   4.60962500e-01,   1.50159566e+00])
exp_amp /= np.sum(exp_amp)

dev_amp = np.array([  4.26347652e-02,   2.40127183e-01,   6.85907632e-01,   1.51937350e+00,
		      2.83627243e+00,   4.46467501e+00,   5.72440830e+00,   5.60989349e+00])
dev_var = np.array([  2.23759216e-04,   1.00220099e-03,   4.18731126e-03,   1.69432589e-02,
		      6.84850479e-02,   2.87207080e-01,   1.33320254e+00,   8.40215071e+00])
dev_amp /= np.sum(dev_amp)

def get_exp_mixture():
	return MixtureOfGaussians(exp_amp, np.zeros((exp_amp.size, 2)), exp_var)

def get_dev_mixture():
	return MixtureOfGaussians(dev_amp, np.zeros((dev_amp.size, 2)), dev_var)

class MixtureOfGaussians():

	# symmetrize is an unnecessary step in principle, but in practice?
	def __init__(self, amp, mean, var):
		self.amp = np.atleast_1d(amp).astype(float)
		self.mean = np.atleast_2d(np.array(mean)).astype(float)
		(self.K, self.D) = self.mean.shape
		self.set_var(var)
		self.symmetrize()
		#self.test()

	def __str__(self):
		result = "MixtureOfGaussians instance"
		result += " with %d components in %d dimensions:\n" % (self.K, self.D)
		result += " amp	 = %s\n" % self.amp.__str__()
		result += " mean = %s\n" % self.mean.__str__()
		result += " var	 = %s\n" % self.var.__str__()
		return result

	def set_var(self, var):
		if var.size == self.K:
			self.var = np.zeros((self.K, self.D, self.D))
			for d in range(self.D):
				self.var[:,d,d] = var
		else:
			# atleast_3d makes bizarre choices about which axes to expand...
			#self.var = np.atleast_3d(np.array(var))
			#print 'var', self.var.shape
			self.var = np.array(var).astype(float)
	def symmetrize(self):
		for i in range(self.D):
			for j in range(i):
				tmpij = 0.5 * (self.var[:,i,j] + self.var[:,j,i])
				self.var[:,i,j] = tmpij
				self.var[:,j,i] = tmpij

	def normalize(self):
		self.amp /= np.sum(self.amp)

	def __add__(self, other):
		assert(self.D == other.D)
		D = self.D
		K = self.K + other.K
		amp  = np.append(self.amp,  other.amp)
		mean = np.append(self.mean, other.mean, axis=0)
		var  = np.append(self.var,  other.var , axis=0)
		assert(amp.shape  == (K,))
		assert(mean.shape == (K, D))
		assert(var.shape  == (K, D, D))
		s = MixtureOfGaussians(amp, mean, var)
		s.normalize()
		return s
		
	def apply_affine(self, shift, scale):
		'''
		shift: D-vector offset
		scale: DxD-matrix transformation
		'''
		assert(shift.shape == (self.D,))
		assert(scale.shape == (self.D, self.D))
		newmean = self.mean + shift
		newvar = self.var.copy()
		for k in range(self.K):
			newvar[k,:,:] = np.dot(scale.T, np.dot(self.var[k,:,:], scale))
		return MixtureOfGaussians(self.amp, newmean, newvar)

	# dstn: should this be called "correlate"?
	def convolve(self, other):
		assert(self.D == other.D)
		newK = self.K * other.K
		D = self.D
		newamp = np.zeros((newK))
		newmean = np.zeros((newK, D))
		newvar = np.zeros((newK, D, D))
		newk = 0
		for k in range(other.K):
			nextnewk = newk + self.K
			newamp[newk:nextnewk] = self.amp * other.amp[k]
			newmean[newk:nextnewk,:] = self.mean + other.mean[k]
			newvar[newk:nextnewk,:,:] = self.var + other.var[k]
			newk = nextnewk
		return MixtureOfGaussians(newamp, newmean, newvar)

	def evaluate_grid_dstn(self, xlo, xhi, ylo, yhi, xstep=1., ystep=1.):
		from mix import c_gauss_2d_grid
		assert(self.D == 2)
		NX = int(round(xhi - xlo + 1))
		NY = int(round(yhi - ylo + 1))
		result = np.zeros((NY, NX))
		rtn = c_gauss_2d_grid(xlo, xstep, NX, ylo, ystep, NY,
							  self.amp, self.mean,self.var, result)
		if rtn == -1:
			raise RuntimeError('c_gauss_2d_grid failed')
		return result

        def evaluate_grid_acm(self, xlo, xhi, ylo, yhi, xstep=1., ystep=1.):
                xgrid  = np.arange(xlo, xhi, xstep)
                ygrid  = np.arange(ylo, yhi, ystep)
                xx, yy = np.meshgrid(xgrid, ygrid)

                # compute inverse covariances
                icovs = np.array([np.linalg.inv(c) for c in self.var])
                dets  = np.array([np.linalg.det(c) for c in self.var])

                # einsum mixture solution
                x        = np.column_stack((xx.flatten(), yy.flatten()))
                centered = x[:,:,np.newaxis] - self.mean.T
                solved   = np.einsum('ijk,lji->lki', icovs, centered)
                logprobs = -0.5*np.sum(solved * centered, axis=1) - \
                            np.log(2*np.pi) - 0.5*np.log(dets) + \
                            np.log(self.amp)
                logprob  = scpm.logsumexp(logprobs, axis=1)
                if len(x.shape) == 1:
                    return np.exp(logprob[0])
                else:
                    return np.exp(logprob).reshape(xx.shape)

	evaluate_grid = evaluate_grid_acm

def mixture_to_patch(mixture, x0, x1, y0, y1, minval=0.):
	'''
	`mixture`: a MixtureOfGaussians
	`x0,x1,y0,y1`: integer bounds [x0,x1), [y0,y1) of the grid to evaluate

	Returns: a Patch object
	'''
	if minval == 0.:
		return mixture.evaluate_grid(x0, x1, y0, y1)
	else:
		#print 'eval grid:', x0,x1,y0,y1
		return mixture.evaluate_grid_approx(x0, x1, y0, y1, 0., 0., minval)
	


if __name__=="__main__":
    import matplotlib.pyplot as plt
    import seaborn as sns
    sns.set_style("white")
    sns.despine()

    emix = get_exp_mixture()
    epatch = emix.evaluate_grid(-1, 1, -1, 1, xstep=.01, ystep=.01)
    vmix = get_dev_mixture()
    dpatch = vmix.evaluate_grid(-1, 1, -1, 1, xstep=.01, ystep=.01)

    fig, axarr = plt.subplots(1, 2)
    axarr[0].imshow(epatch)
    axarr[0].set_title("Exponential")
    axarr[0].axis('off')
    axarr[1].imshow(dpatch)
    axarr[1].set_title("de Vaucouleurs")
    plt.axis('off')
    import os
    plt.savefig(os.path.expanduser("~/exp_vs_dev.png"), bbox_inches='tight')


